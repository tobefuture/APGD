
#loop all the parameter:sample size=489, snp=1000, causal_rate=0.1,cc_ratio=seq(0.1,0.5,0.1)

setwd("G:/My Drive/Study/2-Research/research-bayesian/code/V6")
rm(list = ls())

source("subfunction_baye.r")

##### set the paremeter #####
# cc_ratio <- c(0.2,0.1)
# # the number of core in parallel
# m=c(1:length(cc_ratio))


model_all <- c("Lasso","EN")
model <- model_all[1]
rep_total <- 10

##### load genotype of chr22 from 1000 Genomes : common variant, no missing , HWE
# genotype <- BEDMatrix:::BEDMatrix("G:/My Drive/Study/2-Research/research-bayesian/data/QC_chr22.bed",simple_names = TRUE)
# genotype <- as.matrix(genotype[,1:1000])

# # If the sample size (individual) is small,resample the data and increase the sample size
# thereshold_sample <- 100
# timestart<-Sys.time()
# n_ind <- nrow(genotype)
# if (nrow(genotype) < thereshold_sample) {
#   ge_resample <- c()
#   sam_size_index <- sample(c(1:n_ind),size = thereshold_sample,replace = TRUE)
#   for (i in c(1:thereshold_sample)) {
#     ge_resample <- rbind(ge_resample,genotype[sam_size_index[i],])
#     print(i)
#   }
#   genotype <- ge_resample
#   n_ind <- nrow(genotype)
# }
# write.csv(genotype,file = "genotype.csv")
# timeend<-Sys.time()
# time_gene_data<-difftime(timeend,timestart, units = "mins")
# print(time_gene_data)


genotype <- read.csv("genotype_10000.csv")[,-1]
genotype <- as.matrix(genotype)



main_func <- function(genotype,cc_ratio,model,rep){

  source("subfunction_baye.r")
  library(caret)
  library(CVXR)
  # ##### load genotype of chr22 from 1000 Genomes : common variant, no missing , HWE
  # genotype <- BEDMatrix:::BEDMatrix("data/QC_chr22.bed",simple_names = TRUE)
  # genotype <- as.matrix(genotype[,1:1000])

  ###### generate phenotype #####
  causal_rate <- 0.1
  # cc_ratio <- 0.001
  n_ind <- nrow(genotype)
  n_variant <- ncol(genotype)
  temp <- generate_pheno(genotype,causal_rate,cc_ratio)
  phenotype <- temp[[1]]
  causal_index <- temp[[2]]
  beta_orig <- rep(0,n_variant)
  beta_orig[causal_index] <- 1
  result_all<-matrix(NA,nrow = 0,ncol = 11)
  colnames(result_all) <- c("causal_rate","sample_size","cc_ratio","is_adjust_SC","AUC","TPR","FPR","Accuracy","Precision","F1","model")
  ##### estimate beta : using RMSE to choose the best tunning parameter #####
  # 1. get tunning parameter through cross validation
  alpha_all <- seq(0.1,1,0.1)
  metric <- c("R2","RMSE","MAE")
  is_adjust_SC_all <- c(TRUE,FALSE)
  for (mm in c(1:length(is_adjust_SC_all))) {
    # mm <- 1
    is_adjust_SC <- is_adjust_SC_all[mm]
    ##### calculate adjust SC or not adjust #####
    adj_SC_no <- SC_adjust_or_not(genotype,phenotype,is_adjust_SC)

    #only using the EN model, since alpha=1 corresponding the lasso model
    # model <- c("Lasso","EN")
    result <- cv_model(genotype,phenotype,model,alpha_all,is_adjust_SC,metric[2])
    metrics_save <- result[[1]]
    tunning_para <- result[[2]]
    if (model=="Lasso") {
      beta <- cvx_lasso(genotype,phenotype,adj_SC_no,tunning_para$lambda)
    }else{
      beta <- cvx_en(genotype,phenotype,adj_SC_no,tunning_para$alpha,tunning_para$lambda)
    }


    #define the significant snp based on beta>sd(beta)
    temp_1 <- which(beta>sd(beta))
    beta_sig <- rep(0,n_variant)
    beta_sig[temp_1] <- 1

    #calculate the metrics and auc
    com_acc <-caret::confusionMatrix(as.factor(beta_orig),as.factor(beta_sig))
    roc_plot <- pROC::roc(response=beta_orig, predictor=beta_sig)
    # plot(roc_plot)
    auc <- as.numeric(pROC::auc(roc_plot))

    result_summary <- matrix(NA,nrow = 1,ncol = 11)
    colnames(result_summary) <- c("causal_rate","sample_size","cc_ratio","is_adjust_SC","AUC","TPR","FPR","Accuracy","Precision","F1","model")
    result_summary[1,1] <- causal_rate
    result_summary[1,2] <- n_ind
    result_summary[1,3] <- cc_ratio
    result_summary[1,4] <- is_adjust_SC
    result_summary[1,5] <- auc
    result_summary[1,6] <- com_acc[["byClass"]][["Recall"]]
    #FPR=1-TNR(specificity)
    result_summary[1,7] <- 1-com_acc[["byClass"]][["Specificity"]]
    result_summary[1,8] <- com_acc[["overall"]][["Accuracy"]]
    result_summary[1,9] <- com_acc[["byClass"]][["Precision"]]
    result_summary[1,10] <- com_acc[["byClass"]][["F1"]]
    result_summary[1,11] <- model
    result_all <- rbind(result_all,result_summary)
    write.csv(result_all,file = paste("./result/",paste("model",model,"cc",cc_ratio,"rep",rep, sep = "_"),".csv",sep = ""))
  }
  return(result_all)
}



###### Simulation 1 ######
timestart<-Sys.time()
cc_ratio <- c(0.5,0.4,0.3)
# the number of core in parallel
m=c(1:length(cc_ratio))

library(foreach)
library(doParallel)
# cores <- detectCores(logical=F)

#setup parallel backend to use many processors
#cores=detectCores()
cl=makeCluster(length(m)) #not to overload your computer
registerDoParallel(cl)

typeIerror=foreach(d=1:length(m), .combine=rbind) %dopar% {
  for (i in c(1:rep_total)) {
    tyd=main_func(genotype,cc_ratio[m[d]],model,rep=i) #calling a function
    tyd
  }
}

stopImplicitCluster()
stopCluster(cl)

timeend<-Sys.time()
time<-difftime(timeend,timestart, units = "mins")
sprintf("The %d paremeter: time %f",1,time)


###### Simulation 2 ######
timestart<-Sys.time()
cc_ratio <- c(0.2,0.1,0.08)
# the number of core in parallel
m=c(1:length(cc_ratio))

library(foreach)
library(doParallel)
# cores <- detectCores(logical=F)

#setup parallel backend to use many processors
#cores=detectCores()
cl=makeCluster(length(m)) #not to overload your computer
registerDoParallel(cl)

typeIerror=foreach(d=1:length(m), .combine=rbind) %dopar% {
  for (i in c(1:rep_total)) {
    tyd=main_func(genotype,cc_ratio[m[d]],model,rep=i) #calling a function
    tyd
  }
}

stopImplicitCluster()
stopCluster(cl)

timeend<-Sys.time()
time<-difftime(timeend,timestart, units = "mins")
sprintf("The %d paremeter: time %f",2,time)




###### Simulation 3 ######
timestart<-Sys.time()
cc_ratio <- c(0.05,0.02,0.01)
# the number of core in parallel
m=c(1:length(cc_ratio))

library(foreach)
library(doParallel)
# cores <- detectCores(logical=F)

#setup parallel backend to use many processors
#cores=detectCores()
cl=makeCluster(length(m)) #not to overload your computer
registerDoParallel(cl)

typeIerror=foreach(d=1:length(m), .combine=rbind) %dopar% {
  for (i in c(1:rep_total)) {
    tyd=main_func(genotype,cc_ratio[m[d]],model,rep=i) #calling a function
    tyd
  }
}

stopImplicitCluster()
stopCluster(cl)

timeend<-Sys.time()
time<-difftime(timeend,timestart, units = "mins")
sprintf("The %d paremeter: time %f",3,time)



###### Simulation 4 ######
timestart<-Sys.time()
cc_ratio <- c(0.008,0.005,0.001)
# the number of core in parallel
m=c(1:length(cc_ratio))

library(foreach)
library(doParallel)
# cores <- detectCores(logical=F)

#setup parallel backend to use many processors
#cores=detectCores()
cl=makeCluster(length(m)) #not to overload your computer
registerDoParallel(cl)

typeIerror=foreach(d=1:length(m), .combine=rbind) %dopar% {
  for (i in c(1:rep_total)) {
    tyd=main_func(genotype,cc_ratio[m[d]],model,rep=i) #calling a function
    tyd
  }
}

stopImplicitCluster()
stopCluster(cl)

timeend<-Sys.time()
time<-difftime(timeend,timestart, units = "mins")
sprintf("The %d paremeter: time %f",4,time)





# # # combine all result
# data=c()
# is_adjust_SC_all <- c(TRUE,FALSE)
# for (i in c(1:length(cc_ratio))) {
#   for (j in 1:rep_total) {
#     temp_data=read.csv(paste("./result/",paste("model",model,"cc",cc_ratio[i],"rep",j, sep = "_"),".csv",sep = ""))[,-1]
#     data=rbind(data,temp_data)
#   }
# }
# write.csv(data,file = "./result/result_all.csv")


