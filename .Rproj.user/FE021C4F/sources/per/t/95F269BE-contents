


#' Estimate beta_hat using adjusted Lasso function
#'
#' @param X genotype matrix of m SNPs
#' @param y phenotype vector
#' @param lambda0 one of parameters in Lasso regression, which controls the number of nonzero coefficients.
#' @param method The current methods must be 'APGD' or 'CVX'
#' @param gamma initial value of gamma in APGD. default: 1000
#' @param niter the maximum number of APGD to solve Lasso regression. default: 2000
#' @param crit_beta converge criterion of change of beta. default: 1e-4
#' @param crit_obj converge criterion of change of objective function. default: 1e-8
#' @param quiet decide if exist the output report. default: FALSE
#'
#' @return beta: m length vector of estimated effect sizes, where beta_j != 0 indicates j th SNP is selected in adjusted Lasso regression.
#' @export
#'
#' @examples
#'
adjLasso_Beta <- function(X, y, adjSC, lambda0, method="APGD",
                       gamma=1000, niter=2000, crit_beta=1e-4, crit_obj=1e-8, quiet=FALSE){
  X <- data.matrix(X)
  y <- data.matrix(y)
  # ---- check X y
  if (nrow(X) != nrow(y)){
    stop("Error: Please check the sample size of X and y. They should be the same!")
  } else if (ncol(y) != 1){
    stop("Error: Please check the dimension of y. It should be n*1 vector!")
  }
  # ---- check lambda0
  if (lambda0 <= 0){
    stop("Error: Lambda shoud be lager than 0!")
  }
  # ---- check gamma
  if (gamma <= 0){
    stop("Error: Gamma shoud be lager than 0!")
  }
  # --- check method
  if (method != "APGD" && method != "CVX"){
    stop("Error: The current methods must be 'APGD' or 'CVX'!")
  }

  ####### Setting:
  n <- nrow(X)
  p <- ncol(X)
  if (quiet == FALSE){
    print(paste("Start calculating beta using adjusted Lasso by :", method))
  }
  # - APGD
  if (method == "APGD"){
    beta_est <- matrix(NA, nrow = ncol(X), ncol = niter+2)
    colnames(beta_est) <- paste("beta", seq(0, niter+1))
    obj <- numeric(niter+1)
    beta_est[,"beta 0"] <- beta_est[,"beta 1"] <- 0
    for (k in 1:niter){
      beta_k <- beta_est[,paste("beta", k)]
      z <- y - X %*% beta_k
      obj[k] <- sum(z^2) + 2*(t(y)%*%X - t(adjSC))%*%beta_k + lambda0*sum(abs(beta_k))
      ksi <- beta_est[,paste("beta", k)] + k/(k+3) * (beta_est[,paste("beta", k)] - beta_est[,paste("beta", k-1)])
      g_grad_ksi <- 2*t(X) %*% X %*% ksi - 2*adjSC
      g_grad_ksi <- data.matrix(g_grad_ksi)
      while (TRUE){
        theta <- ksi - gamma * g_grad_ksi
        beta_prox <- sign(theta) * pmax(abs(theta)-gamma*lambda0, 0)
        g_ksi <- sum((y - X %*% ksi)^2) + 2*(t(y)%*%X - t(adjSC))%*%ksi
        g_beta_prox <- sum((y - X %*% beta_prox)^2) + 2*(t(y)%*%X - t(adjSC))%*%beta_prox
        g_hat_upper <- g_ksi + t(g_grad_ksi)%*%(beta_prox-ksi) + 0.5/gamma*sum((beta_prox-ksi)^2)
        if (g_beta_prox <= g_hat_upper){
          break
        } else {
          gamma <- 0.5*gamma
        }
      }
      beta_est[,paste("beta", k+1)] <- beta_prox
      z <- y - X %*% beta_prox
      obj[k+1] <-  sum(z^2) + 2*(t(y)%*%X - t(adjSC))%*%beta_prox + lambda0*sum(abs(beta_prox))
      diff_beta <- beta_prox - beta_est[,paste("beta", k)]
      temp_beta <- (sum(abs(diff_beta) >= crit_beta) == 0)
      temp_obj <- (abs(obj[k+1] - obj[k]) < crit_obj)
      temp <- (1 - temp_beta) * (1 - temp_obj)
      if (k>1 && temp==0){
        break
      }
    }
    if (k == niter){
      print("Waining: Setting number of iterations doesn't reach to the convergency. Please set larger 'niter'!")
    }
    beta_hat <- beta_est[,k]
  } else {   # - CVX
    # if (!requireNamespace("CVXR", quietly = TRUE)) install.packages("CVXR")
    library(CVXR)
    n_variant <- ncol(X)
    beta_lasso <- Variable(n_variant)
    obj_lasso <- (sum_squares(y - X %*% beta_lasso) + 2 * t(t(X) %*% y-adjSC) %*% beta_lasso)/n + lambda0*p_norm(beta_lasso, 1)
    prob <- Problem(Minimize(obj_lasso))
    result <- CVXR::solve(prob)
    beta_hat <- result[[1]]


    library(CVXR)
    n_variant <- ncol(X)
    beta_lasso <- Variable(n_variant)
    obj_lasso <- (sum_squares(y - X %*% beta_lasso) + 2 * t(t(X) %*% y-adjSC) %*% beta_lasso)/n + lambda0*p_norm(beta_lasso, 1)
    prob <- Problem(Minimize(obj_lasso))
    result <- CVXR::solve(prob)
    beta_hat <- result[[1]]

  }

  return(beta_hat)
}
